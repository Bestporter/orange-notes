# python中的GIL

## 进程

>  进程间通信（IPC，Interprocess communication）是一组编程接口，因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。IPC接口就提供了这种可能性。　
>
> IPC方法包括管道（PIPE）、消息排队、旗语、共用内存以及套接字（Socket）。

### IPC的目的：

> 1）数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
>
> 2）共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
>
> 3）通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知[父进程](https://baike.baidu.com/item/父进程)）。
>
> 4）资源共享：多个进程之间共享同样的资源。为了做到这一点，需要[内核](https://baike.baidu.com/item/内核)提供锁和同步机制。
>
> 5）进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### 信号

> 信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的[虚拟内存](https://baike.baidu.com/item/虚拟内存)中不存在的位置等）都有可能产生一个信号。Shell也使用信号向它的子进程发送[作业控制](https://baike.baidu.com/item/作业控制)信号。

在一个信号的生命周期中有两个阶段：生成和传送。当一个事件发生时，需要通知一个进程，这时生成一个信号。当进程识别出信号的到来，就采取适当的动作来传送或处理信号。在信号到来和进程对信号进行处理之间，信号在进程上挂起（pending）。

内核为进程生产信号，来响应不同的事件，这些事件就是信号源。

主要的信号源：

异常：进程运行过程中出现异常；

其它进程：一个进程可以向另一个或一组进程发送信号；

终端中断：Ctrl-C，Ctrl-\等；

[作业控制](https://baike.baidu.com/item/作业控制)：前台、后台进程的管理；

分配额：CPU超时或文件大小突破限制；

通知：通知进程某事件发生，如I/O就绪等；

报警：计时器到期。

### 管道

> 管道包括三种:
>
> 1)普通管道PIPE, 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
>
> 2)流管道s_pipe: 去除了第一种限制,为半双工，可以双向传输.
>
> 3)[命名管道](https://baike.baidu.com/item/命名管道):name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.命名管道是一种[FIFO](https://baike.baidu.com/item/FIFO/64838)（先进先出，First-In First-Out）对象。

线程与进程的区别

线程与进程的区别可以归纳为以下4点：

1. 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
2. 通信：[进程间通信IPC](https://baike.baidu.com/item/进程间通信)，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要[进程同步](https://baike.baidu.com/item/进程同步)和互斥手段的辅助，以保证数据的一致性。
3. 调度和切换：线程上下文切换比进程上下文切换要快得多。
4. 在多线程操作系统中，进程不是一个可执行的实体。 　　





线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：**所有线程都具有相同的进程id**，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信***不必调用内核。***

## GIL是什么

在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整,执行字节码 行数），进行释放。

```
# dis库是python(默认的CPython)自带的一个库,可以用来分析字节码，查看cpu运行轨迹，也就是cpu指令      
import dis                                         
def add(a):                                        
    a = a + 1                                      
    return a                                       
dis.dis(add)
```

而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，**但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。**

而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高

**多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低**



```python
import threading
total = 0
def add():
    global total
    for i in range(1000000):
        total += 1
def desc():
    global total
    for i in range(1000000):
        total -= 1
thread1 = threading.Thread(target=add)
thread2 = threading.Thread(target=desc)
thread1.start()
thread2.start()

thread1.join()
thread2.join()
print(total)
# 每次执行结果都不一样（如果GIL锁不释放，结果用于为0）
# 所以该代码表面了，在多线程执行过程中，GIL锁被释放掉，被其他线程获取

```

**综上**：GIL会根据执行的字节码行数（py2），时间片（py3）和遇到io操作时释放（py2，py3）

我们进行分类讨论：

1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以**python下的多线程对CPU密集型代码并不友好。**

2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。**所以python的多线程对IO密集型代码比较友好。**



每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。

**所以我们能够得出结论：多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率**





程序中任务执行的本质是CPU作为执行者运行代码，因此并行必定意味着多核，并发好比单核切换交替执行多个任务。

由于Python解释器中GIL全局解释器锁的问题，Python的多线程只能实现并发，多进程才能实现并行。而协程是在单线程中实现的，因此协程也只能实现并发。



因而多进程、多线程的切换是操作系统负责的，而协程的切换不是由操作系统的。



也就是说只要是单线程中实现了多个任务的交替/切换的执行，那么它就是协程。同时协程的切换本质上由用户控制。



协程的实现方式其实都是通过将CPU的执行环境(控制单元、存储单元、运算单元)进行替换实现的。因为CPU只根据它控制单元、存储单元、运算单元里的东西来运算。



切换



如当前CPU正在运行函数1，那么此时直接将函数1在CPU的运行情况保存起来，然后替换成函数2的，这样就实现了从函数1到函数2的切换。

具体实现一般分为两种情况：

- 一种是语言特性，原生支持，如Python的yield、Go的goroutine等；
- 另一种是第三方模块的单独实现，如gevent中的使用的greenlet。

**IO密集任务与计算密集任务**

- IO密集型：适合多线程或协程
  - 大量磁盘I/O操作（文件读写、磁盘读写）
  - 大量网络I/O操作（网络请求、socket程序）
- 计算密集型：适合多进程
  - 大量运算操作（计算精确到小数点1000位的圆周率、视频高清解码、图像运算）
  - 大量逻辑判断操作（循环判断、if判断等大量逻辑代码处理）
- 原因：
  - I/O操作不会占用CPU，多线程、协程能同时处理多个I/O操作
  - 计算操作需要一直使用CPU，多进程能利用多个核心
  - 多进程资源开销比多线程资源开销大很多

**网络应用是I/O密集型应用**，爬虫程序是I/O密集型应用。

而显然针对I/O密集型程序，协程开销相较于线程小得多