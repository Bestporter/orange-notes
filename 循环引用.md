**循环引用**（Retain Cycle） 因为B强**引用**A，A的**引用**计数永远不**会**减为0，当A原本的强**引用**对象被释放以后，A和B成为了一个相互**引用**的孤岛，永远不**会**被释放了，这就**会**引起**内存泄漏**。



循环引用

> [参考博客](https://hustyichi.github.io/2018/10/30/circular-import/)
>
> 

> 《python核心编程》
>
> 加载模块会导致这个模块被执行。也就是被执行模块的顶层代码将直接被执行。这通常包含设定全局变量以及类和函数的声明
>
> 一个模块只被加载一次，无论它被导入多少次。这可以阻止多重导入时代码被多次执行

可以看到引用的调用的路线如下所示：

1. 引用`my_test2/c`模块
2. 由于是第一次引用`my_test2/c`模块，此时会执行`my_test2/c.py`文件，此时会执行`from my_test import a`
3. 此时执行了包`my_test/__init__.py`的代码，执行了`from . import b`，引用了模块`my_test/b`
4. 模块`my_test/b`由于是第一次被引用，会执行其中的代码，执行`from my_test2 import c`，循环引用出现，报错

上面的路径最初看起来一些符合预期，但是在第3步就看起来有一些奇怪了，为什么会执行包`my_test/__init__.py`的代码，看起来是引用包内的元素时，可能会执行包初始化的代码，一般搜索加验证之后确定

> **第一次引用包内模块或包时，都会执行包的初始化代码，即包内的`__init__.py`的代码**





循环引用的解决办法

弱引用消除了引用循环的这个问题，本质来讲，弱引用就是一个对象指针，它不会增加它的引用计数。 你可以通过 `weakref` 来创建弱引用。例如：

```
>>> import weakref
>>> a = Node()
>>> a_ref = weakref.ref(a)
>>> a_ref
<weakref at 0x100581f70; to 'Node' at 0x1005c5410>
>>>
```

为了访问弱引用所引用的对象，你可以像函数一样去调用它即可。如果那个对象还存在就会返回它，否则就返回一个None。 由于原始对象的引用计数没有增加，那么就可以去删除它了。例如;

```
>>> print(a_ref())
<__main__.Node object at 0x1005c5410>
>>> del a
Data.__del__
>>> print(a_ref())
None
>>>
```

通过这里演示的弱引用技术，你会发现不再有循环引用问题了，一旦某个节点不被使用了，垃圾回收器立即回收它。 你还能参考8.25小节关于弱引用的另外一个例子。